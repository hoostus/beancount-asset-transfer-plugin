__plugins__ = ['transfer']

import collections

from beancount.core import data
from beancount.core import account
from beancount.core.amount import Amount
import beancount.core.flags
import beancount.query.query

TransferError = collections.namedtuple('TransferError', 'source message entry')

CUSTOM_DIRECTIVE = 'transfer'

def transfer(entries, option_map):
    errors = []
    new_entries = []

    (rtypes, rrows) = beancount.query.query.run_query(entries, option_map, """
        SELECT account,
        units(sum(position)) as units,
        cost_number as cost,
        first(getprice(currency, cost_currency)) as price,
        cost(sum(position)) as book_value,
        value(sum(position)) as market_value,
        cost_date as acquisition_date
        GROUP BY account, cost_date, currency, cost_currency, cost_number
        ORDER BY currency, cost_date
    """)

    accounts = collections.defaultdict(list)
    for r in rrows:
        accounts[r.account].append(r)

    for entry in entries:
        if isinstance(entry, data.Custom) and entry.type == CUSTOM_DIRECTIVE:
            if len(entry.values) != 3:
                errors.append(TransferError(entry.meta, "Asset transfer requires 3 parameters: source_account, amount, destination_account", entry))
                continue

            amount, source_account, destination_account = entry.values

            if amount.dtype != Amount:
                errors.append(TransferError(entry.meta, "First parameter is not recognized as a valid beancount Amount.", entry))
                continue

            if source_account.dtype != account.TYPE:
                errors.append(TransferError(entry.meta, "Source account for transfer does not appear to be an account.", entry))
                continue

            if destination_account.dtype != account.TYPE:
                errors.append(TransferError(entry.meta, "Destination account for transfer does not appear to be an account.", entry))
                continue

            # Unwrap the actual beancount classes from the namedtuples
            amount = amount.value
            found_amount = 0
            currency = amount.currency
            source_account = source_account.value
            destination_account = destination_account.value

            # Process lots LIFO
            lots = sorted(accounts[source_account], key=lambda a: a.acquisition_date, reverse=True)
            for lot in lots:
                currency_units = lot.units.get_currency_units(currency)
                if currency_units.number == 0:
                    continue
                reduce_amount = min(currency_units.number, amount.number)
                found_amount += reduce_amount
                
                # generate 2 postings
                #breakpoint()
                #cost = data.Cost(lot.cost, currency, lot.acquisition_date, None)
                pos = lot.book_value.get_only_position()
                cost = data.Cost(lot.cost, pos.units.currency, lot.acquisition_date, None)
                from_posting = data.Posting(account = source_account,
                    units = Amount(-reduce_amount, currency),
                    cost = cost,
                    price = None,
                    flag = None,
                    meta = entry.meta)
                to_posting = data.Posting(account = destination_account,
                    units = Amount(reduce_amount, currency),
                    cost = cost,
                    price = None,
                    flag = None,
                    meta = entry.meta)

                amount = Amount(amount.number - reduce_amount, currency)

                new_entry = data.Transaction(flag = beancount.core.flags.FLAG_TRANSFER,
                    payee = 'Asset Transfer',
                    narration = 'Automatically generated by asset transfer plugin',
                    date = entry.date,
                    tags = set(["in-kind-transfer"]),
                    links = data.EMPTY_SET,
                    meta = entry.meta,
                    postings = [from_posting, to_posting]
                )

                new_entries.append(new_entry)
                if amount.number == 0:
                    break
            if amount.number != 0:
                errors.append(TransferError(entry.meta, f"Found {found_amount} of {currency} in {source_account}. Expected {amount.number} more.", entry))
        else:
            new_entries.append(entry)

    return new_entries, errors
